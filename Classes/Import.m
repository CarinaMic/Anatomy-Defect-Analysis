classdef Import
    % Import class to import stl/xls-data of a pelvis
    
    % Developed by C.Micheler,
    % Department of Orthopaedics and Sportorthopaedics, TUM School of Medicine and Health, Klinikum rechts der Isar, Technical University of Munich
    % Institute for Machine Tools and Industrial Management, TUM School of Engineering and Design, Technical University of Munich   
    

    properties 
        loaded = struct();      % Import: loaded data 
        processed = struct();   % Import processed: processed loaded data           
    end
    
    methods
        %% Constructer: generate object
        function obj = Import(pelvisNum)
            % pelvisNum: Identifier for the pelvis
            disp(['class import initialized: pelvis ',num2str(pelvisNum)])
        end
        
        %% Import pelvis data/infos
        function obj = importData(obj,pelvisNum,filename)
            
            % Import data from excel file: Auto-generated by MATLAB; 
            % Further developed by C.Micheler,
            % Department of Orthopaedics and Sportorthopaedics, TUM School of Medicine and Health, Klinikum rechts der Isar, Technical University of Munich
            % Institute for Machine Tools and Industrial Management, TUM School of Engineering and Design, Technical University of Munich
            
            %% Set up the Import Options and import the data
            opts = spreadsheetImportOptions("NumVariables", 5);
            
            % Specify sheet and range
            opts.Sheet = "Tabelle1";
            opts.DataRange = "A2:E18";
            
            % Specify column names and types
            opts.VariableNames = ["x", "y", "z", "Landmark", "Paprosky"];
            opts.VariableTypes = ["double", "double", "double", "string", "string"];
            
            % Import the data
            inputData = readtable(filename, opts, "UseExcel", false);
            
            %% Convert to output type
            data = table2array(inputData(:,1:3));

            % Load Paprosky information
            obj.loaded.paprosky = table2array(inputData(1,5));
            obj.processed.paprosky = table2array(inputData(1,5));
            % Load PelvicSide information
            obj.loaded.pelvicSide = table2array(inputData(2,5));
            obj.processed.pelvicSide = table2array(inputData(2,5));

            % Landmarks list
            allLandmarks = {'asis', 'tb', 'psis', 'piis', 'si', 'acentre', ...
                'aiis', 'iim', 'iimin', 'spp', 'spd', 'ti', ...
                'fo_p', 'fo_i', 'fo_a', 'fo_ip', 'ci'};

            % Helper function to transform the landmark names for matching
            transformName = @(name) strrep(name, '_', '-');

            % Extracting landmark names from inputData
            availableLandmarks = table2array(inputData(:,4));

            % Populate the loaded and processed structures for available landmarks
            for idx = 1:length(allLandmarks)
                landmarkName = allLandmarks{idx};

                % Transform landmark name for matching
                transformedName = transformName(landmarkName);

                % Find index of the landmark in inputData
                landmarkIdx = find(strcmp(availableLandmarks, transformedName));
                if ~isempty(landmarkIdx)
                    obj.loaded.(landmarkName) = data(landmarkIdx, :);
                    % Processed data: Mirroring if the pelvic side is right (yz plane)
                    if obj.loaded.pelvicSide == "right" && ~any(isnan(data(landmarkIdx, :)))
                        modifiedData = data(landmarkIdx,:);
                        modifiedData(1) = -modifiedData(1);
                        obj.processed.(landmarkName) = modifiedData;
                    else
                        obj.processed.(landmarkName) = data(landmarkIdx,:);
                    end
                end
            end

            % Check if 'fo_p', 'fo_i', 'fo_a', 'fo_ip' are available
            if isfield(obj.processed, 'fo_p') && ...
                    isfield(obj.processed, 'fo_i') && ...
                    isfield(obj.processed, 'fo_a') && ...
                    isfield(obj.processed, 'fo_ip')

                % Calculation of landmark fo (centre of foramen obturatum)
                % https://studyflix.de/mathematik/abstand-windschiefer-geraden-2008
                % Straight line equation with two points (P,Q): x = P + lambda*(P-Q)
                % Line fo-p to fo-i (main axis fo elipse): x = fo_p + lambda*u
                u_main = obj.processed.fo_p - obj.processed.fo_i;
                % Line fo-a to fo-ip (minor axis fo elipse): x = fo_a + phi*u
                u_minor = obj.processed.fo_a - obj.processed.fo_ip;
                % Vector perpendicular to both direction vectors of the straight line:
                % cross product of u_main and u_minor
                n = cross(u_main, u_minor);
                % Auxiliary plane: x = fo_p + lambda*u_main + omega*n
                % Plump bob point: equalise auxiliary plane and line fo-a to fo-ip
                % fo_p + lambda*u_main + omega*n = fo_a + phi*u_minor
                % System of equations: lampda*u_main + omega*n - phi*u_minor = fo_a-fo_p
                % gr = inv(A)*(fo_a-fo_p); gr = [lambda; omega; phi]
                A = [u_main', n', (-u_minor)'];
                b = (obj.processed.fo_a - obj.processed.fo_p)';
                gr = A\b; % system of equations
                % Plump bob points with straight line equations
                S1 = obj.processed.fo_p + gr(1)*u_main;
                S2 = obj.processed.fo_a + gr(3)*u_minor;
                % Centre point of vector S1-S2 (half distance)
                obj.processed.fo = 0.5 * (S1 + S2);

            else
                disp(['Landmarks fo_p, fo_i, fo_a, and fo_ip are not all available. Skipping "fo" calculation: pelvis ',...
                    num2str(pelvisNum)])
            end
            
            disp(['data loaded: pelvis ',num2str(pelvisNum)])
            
        end
        
        %% Import stl
        function obj = importSTL(obj,pelvisNum,filename)
            % Test before (f.e. in Blender) if the stl-file is correct and the normals show in the right direction (outwards).
            
            % File Exchange stlread: -> put stlread-Function in Functions folder (overwrites built-in Matlab function)
            % https://de.mathworks.com/matlabcentral/fileexchange/22409-stl-file-reader?focused=5193625&tab=function
            % Import STL mesh and return a PATCH-compatible face-vertex-normal structure
            %[obj.loaded.faces,obj.loaded.vertices,obj.loaded.normals] = stlread(filename); % Function stlread
            
            % Use the built-in MATLAB stlread function
            % Vertices/faces do not require restructuring (stlStruct function) with built-in stlread
            obj.loaded.TR = stlread(filename);
            obj.processed.vertices = obj.loaded.TR.Points;
            obj.processed.faces = obj.loaded.TR.ConnectivityList;
            % Compute the face normals
            V1 = obj.loaded.TR.Points(obj.loaded.TR.ConnectivityList(:,1),:);
            V2 = obj.loaded.TR.Points(obj.loaded.TR.ConnectivityList(:,2),:);
            V3 = obj.loaded.TR.Points(obj.loaded.TR.ConnectivityList(:,3),:);
            Normals = cross(V2 - V1, V3 - V1, 2);
            % Normalize the normals
            obj.loaded.normals = Normals ./ vecnorm(Normals,2,2);
            obj.processed.normals = obj.loaded.normals;

            % Pelvic half of the right side -> mirroring
            % Mirroring at yz-plane -> x-Coordinate * (-1)
            if obj.loaded.pelvicSide=="right"
                obj.processed.vertices(:,1) = (-1) * obj.processed.vertices(:,1);
                % Mesh: normal orientation to the center -> defines the outside of the mesh
                % The orientation of the normal is defined by the ordering of the vertices in a triangle (faces strcuture).
                % The ordering follows the right-hand rule.
                obj.processed.faces = obj.loaded.TR.ConnectivityList(:,[1,3,2]);
                % Compute the face normals
                v1 = obj.processed.vertices(obj.processed.faces(:,1),:);
                v2 = obj.processed.vertices(obj.processed.faces(:,2),:);
                v3 = obj.processed.vertices(obj.processed.faces(:,3),:);
                normals = cross(v2 - v1, v3 - v1, 2);
                % Normalize the normals
                obj.processed.normals = normals ./ vecnorm(normals,2,2);
            end
                        
            disp(['STL data loaded: pelvis ',num2str(pelvisNum)])
        end
        %% Structure of vertices, faces and normals (for File Exchange stlread function)
        function obj = stlStruct(obj,pelvisNum)    
            % For File Exchange stlread function: vertices can have duplicates
            % Structure of vertices and faces after stlread-function:
            % Vertices: Array with three columns(x,y,z-coordinates);
            %           Vertices are duplicated for the face structure;
            % Faces:    Array with three columns; 
            %           Sequentially numbered in ascending order [1 2 3; 4 5 6; ...] 
            %           -> Duplicated vertices (f.e. vertices 3 & 4 are identic);
            %           Each row presents one face; 
            %           Each line containts the vertices numbers (row number) for one face;

            % New structure:
            % Vertices: Array with three columns(x,y,z-coordinates);
            %           Vertices are not duplicated for the face structure;
            %           -> Reduces computing time later;
            % Faces:    Array with three columns; 
            %           Each row presents one face; 
            %           Each line containts the vertices numbers (row number) for one face 
            %           -> New order to link the correct vertices;

            % Function: Find duplicates in vertices, remove them and 
            % modify the array for the faces so that the correct vertices are linked
            % https://de.mathworks.com/matlabcentral/fileexchange/57155-unifyvertex-faces-vertices
            
            % Find duplicates in vertices (unique)
            [vertices_woDup,~,vertices_numDup] = unique(obj.loaded.vertices,'rows','stable');

            faces_in = obj.loaded.faces'; % Transpose for following calculation
            faces_in(:) = vertices_numDup(:); % Replace the duplicates with the first occurence
            obj.processed.faces = faces_in'; % Output: new faces structure

            obj.processed.vertices = vertices_woDup; % Output: new vertices structure
            
            % Pelvic half of the right side -> mirroring
            if obj.loaded.pelvicSide=="right"
                % Mirroring at yz-plane -> x-Coordinate * (-1)
                obj.processed.vertices(:,1) = (-1) * obj.processed.vertices(:,1);
                % Mesh: normal orientation to the center -> defines the outside of the mesh
                % The orientation of the normal is defined by the ordering of the vertices in a triangle (faces strcuture).
                % The ordering follows the right-hand rule.
                obj.processed.faces = faces_in([1;3;2],:)';
            end
            
            obj.processed.normals = obj.loaded.normals;
            
            disp(['STL data restructured: pelvis ',num2str(pelvisNum)])
        end
        %% Centroid of the faces (for the normal vector)
        function obj = centroid(obj,pelvisNum)
            % Calculate the centroid of the triangular faces in the mesh
            V1 = obj.processed.vertices(obj.processed.faces(:,1),:);
            V2 = obj.processed.vertices(obj.processed.faces(:,2),:);
            V3 = obj.processed.vertices(obj.processed.faces(:,3),:);
            faceVertices = cat(3, V1, V2, V3);
            obj.processed.centreFaces = mean(faceVertices, 3);

            disp(['Centroids of the faces calculated: pelvis ', num2str(pelvisNum)]);
            
        end

        %% Mean edge length
        function obj = edgeLength(obj,pelvisNum)
            % Calculate the edge length of the triangular faces in the mesh

            edgeLengths = []; % Initialize an array to store edge lengths
            for i = 1:size(obj.processed.faces,1)
                % Vertices of the triangle
                V1 = obj.processed.vertices(obj.processed.faces(i,1),:);
                V2 = obj.processed.vertices(obj.processed.faces(i,2),:);
                V3 = obj.processed.vertices(obj.processed.faces(i,3),:);

                % Calculate lengths of each edge of the triangle
                edgeLengths(end+1) = norm(V1 - V2); % Edge 1-2
                edgeLengths(end+1) = norm(V2 - V3); % Edge 2-3
                edgeLengths(end+1) = norm(V3 - V1); % Edge 3-1
            end

            meanEdgeLength = mean(edgeLengths);
            stdEdgeLength = std(edgeLengths);
            maxEdgeLength = max(edgeLengths);
            minEdgeLength = min(edgeLengths);

            obj.processed.edgeLength = edgeLengths';
            obj.processed.meanEdgeLength = meanEdgeLength;
            obj.processed.stdEdgeLength = stdEdgeLength;
            obj.processed.maxEdgeLength = maxEdgeLength;
            obj.processed.minEdgeLength = minEdgeLength;

            disp(['Edge length calculated: pelvis ', num2str(pelvisNum)]);
            
        end
        
    end
end